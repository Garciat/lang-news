---
title: "A Comment-Preserving Cabal Parser"
date: 2025-12-25
language: haskell
source: "https://blog.haskell.org/a-comment-preserving-cabal-parser/"
tags: [cabal]
---

[LÃ©ana Jiang](https://blog.haskell.org/authors/leana-jiang/)  December 25, 2025  [[Cabal](https://blog.haskell.org/categories/cabal/)] #[activities-report](https://blog.haskell.org/tags/activities-report/) 

    

*This article was originally posted on my blog [here](https://confusedcompiler.org/articles/2025-12-comment-preserving-cabal-parser).*

# Motivation

Cabal [1](#1) is the standard package system for Haskell software, it is similar to Cargo from the Rust
world, or OPAM if you come from OCaml.
Cabal reads cabal package manifests in the cabal format (with the extension `.cabal`).
However, it is currently unable to modify it loselessly: comments are lost, imports are
fused and written in place, `elif` in a conditional will be desugared to a nested `if` in an `else`.
A tracking issue was opened in cabal's repository since 2021 [here](https://github.com/haskell/cabal/issues/7544).
For this reason, critical features such as adding modules to the .cabal manifest or generating
package dependency bounds are implemented poorly.
For example, cabal emits a warning when a module is not listed in the manifest, but it can't apply
the fix the warning indicates for you.
Furthermore, `cabal gen-bounds` (which generates dependency bounds that are not specified) doesn't
write dependency bounds information directly to the cabal file, it dumps them to the terminal.
Frustrating!
If we use the current pretty printer in cabal to try to implement these features, the resulting
cabal manifest will be mangled.
This is because cabal can't do *exact printing* yet.
Concretely this means the spaces and empty lines, comments, common stanzas, and if conditions that
you add will be lost.
Adding an exact printer will allow cabal to modify the cabal files automatically and loselessly!
An exact printer is a special kind of pretty printer.
It uses concrete syntax information in the in-memory representation to output a file that is
byte-to-byte identical to the file originally parsed.
To do that, its corresponding parser must store enough information in the in-memory
representation.
Formally, the exact parser/printer combination obeys the law presented below.
forall cabalFile.
  IsValid cabalFile =>
    exactPrint (exactParse cabalFile) == cabalFile

This reads as "for all valid cabal manifests, the operation `exactPrint . exactParse` should output a
file that is byte-to-byte identical to the original".
Furthermore, we also aim to allow modification to the in-memory representation. Unmodified parts of
the representation will be printed out verbatim to the original parsed cabal file.
This property is crucial for tools to be able to manipulate cabal files programmatically:
adding dependency, export a module, or generate package bounds just to name a few.
In order to achieve introducing an exact printer, the first step is to preserve concrete syntax information. For example,
comments must not be altered, comma style in comma-separated fields must be preserved, blank spaces
and bla

...

*Content truncated. Please visit the original article for the full post.*