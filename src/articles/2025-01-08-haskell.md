---
layout: article.vto
title: "Case Study — Using a JavaScript component inside a Haskell application"
date: 2025-01-08
language: haskell
source: "https://blog.haskell.org/case-study-foreign-integration-js-browser/"
tags: [news]
version: ""
url: /articles/2025-01-08-haskell/
---

[Mateusz Goślinowski](https://blog.haskell.org/authors/mateusz-goslinowski/)  January 08, 2025  [[GHC](https://blog.haskell.org/categories/ghc/)] #[javascript](https://blog.haskell.org/tags/javascript/)  #[case-study](https://blog.haskell.org/tags/case-study/) 

    

GHC since version 9.8 allows us to create callbacks from JS to Haskell code, which enables us to create full-fledged browser apps.
This article shows how to use the JS backend with foreign component libraries.

- repository: https://github.com/Swordlash/halogen-blog

- ghc used: javascript-unknown-ghcjs-ghc-9.12.1 (ghcup)

## Preface

Any useful browser single-page application needs to be able to react to user input to modify the webpage content on response.
Since GHC version 9.8 release, we can instantiate JavaScript-level functions with Haskell closures, allowing us to pass Haskell-level actions to DOM event listeners.
foreign import javascript unsafe 
  """ 
  ((f) => { 
    var node = document.createElement("button"); 
    node.textContent = "Click me!"; 
    node.onclick = () => { 
      node.textContent = `Clicked ${f()} times`;
    }; 
    document.body.appendChild(node);
  })
  """
  install_handler :: Callback (IO JSVal) -> IO ()

main :: IO ()
main = do
  ref <- newIORef 0
  let incRef = toJSInt <$> (modifyIORef&#39; ref (+1) *> readIORef ref)
  syncCallback&#39; incRef >>= install_handler

In the above snippet we're creating an `IORef` and pass a callback incrementing it to a foreign function that installs a button in body, counting a number of clicks
(note for brevity I used a multiline syntax that is not yet available for foreign calls). The callback closes over the `IORef` and correctly updates the number after each click.

Callbacks fully enable probably the most fascinating purpose of JavaScript backend, which is web programming. GHCJS has been around for quite some time now,
however it is both outdated (being a GHC fork requiring separate maintenance; currently stuck on 8.10) and cumbersome to use (often necessitating a separate setup, typically through Nix). In one of my previous companies, while evaluating potential options for rewriting the frontend, I decided to use PureScript. It was close enough to Haskell and very easy to set up - it can be installed directly through `npm`, has its own `stack`-like package manager `spago` with a suite of existing bundler plugins, and a blazing fast language server.
During this journey I was using [purescript-halogen](https://github.com/purescript-halogen/purescript-halogen) library - a typesafe, declarative VDOM framework based on [The Elm Architecture](https://guide.elm-lang.org/architecture/).
However, with all the joy that the Haskell-like web programming brought me, I couldn't shake the feeling that there is a room for improvement. From the small things that are
always annoying in polyglot stacks (like FE-BE JSON encoding discrepancies or lack of code sharing), to sometimes very illegible `purs` compiler error messages an

...

*Content truncated. Please visit the original article for the full post.*